# Data Structure

> python으로 알아보는 자료구조



## :bulb: Intro

프로그램은 데이터를 표현하고 처리하는 것이다. 여기서 데이터를 표현하는 것은 데이터를 어떻게 저장하는지를 나타낸다. 실세계에 존재하는 데이터를 가장 적합한 형태로 표현할 수 있어야한다.

프로그램에서 하나의 데이터를 숫자형, 문자형과 같은 `자료형`에 변수이름을 지어서 저장한다. 또한 같은 자료형을 갖는 연속적인 데이터를 배열, 연결 리스트와 같은 `자료구조`에 저장한다. 이러한 자료구조를 통해 데이터를 삽입, 삭제와 같은 기능을 가진 스택, 큐와 같은 `추상 자료형`을 정의하기도 한다.

`자료형`, `자료 구조`, `추상 자료형`은 데이터를 저장한다는 의미에서 비슷하지만 명확하게 구분할 수 있어야한다. 

- `자료형` : 컴파일러 또는 인터프리터에게 어떤 속성을 갖는 데이터를 사용하는지 알려주기 위해 사용된다.
- `자료 구조` : 메모리 공간에서 일련의 데이터를 효율적으로 접근하고 수정하기위해 데이터를 관리하고 저장하는 것이다. *(**추후 다시 개념정의하기**)*
- `추상 자료형` : 데이터들의 행동을 정의한 것이다. 예를 들어 데이터를 삽입하면 삭제할 때는 데이터를 삽입한 순서대로 삭제할 것이다 -> `FIFO` -> 이러한 기능을 가진 자료형을 `큐`라고 부를 것이다.



## Array

배열은 크기를 지정하고 해당 크기만큼 연속된 메모리 공간에 데이터를 저장하는 자료구조이다. 배열은 어느 위치에 있든 `O(1)`로 조회가 가능하다. 

배열은 크기가 고정되어있기 때문에 처음에 정한 크기보다 적게 저장하면 사용하지 않는 공간이 낭비가 되며, 처음에 정한 크기보다 더 많은 데이터를 저장할 수 없다. 하지만 `동적 배열`은 데이터의 양에 따라 크기를 늘리고 줄일 수 있다.

**동적 배열**은 초깃값을 작게 잡아 생성 후에 데이터가 추가되어 꽉 차게된다면 크기를 늘려주고 복사하게 된다. 흔히 2배씩 늘려주는 것을 `더블링`이라 한다.

python의 경우 초반에는 2배씩 늘려가다가 전체적으로 약 1. 125배로 늘려 나간다.



## Linked  List

연결 리스트는 데이터 요소의 선형 집합으로 데이터의 순서가 메모리에 물리적으로 순서대로 저장되지 않는다. 배열과 함께 기본이 되는 선형 자료구조이다.

연결 리스트를 통해 다양한 추상 자료형을 구현한다.

동적으로 새로운 노드를 삽입하거나 삭제하기 편리하며, 노드들이 연결 구조로 되어있어 메모리를 연속적으로 사용하지 않아도 되기 때문에 관리도  쉽다.

이러한 구조 때문에 배열과 달리 특정 인덱스에 접근하기 위해서는 `O(n)`의 시간이 소요된다. 하지만 특정 인덱스에 데이터를 추가하거나 삭제하는 것은 `O(1)`의 시간이 소요된다.



## 선형 자료구조

### Stack

스택은 데이터를 한 쪽에서만 넣고 빼는 자료구조이다. 그렇기 때문에 후입선출 `Last In First Out - LIFO`의 특징을 갖고있다. 데이터를 입력하면 계속 쌓이는 구조가되며 가장 마지막에 넣은 데이터가 맨 위에 위치한다.

python에서는 `list`를 활용하여 스택을 구현할 수 있다. 데이터를 넣고 빼는 입구가 하나로 생각하고 맨 뒤로 데이터를 넣고 빼도록한다.

- `.append()` : 스택에 데이터를 넣는다.
- `stack[-1]` : 맨 뒤에 있는 데이터를 가리킨다.
- `.pop()` : 맨 뒤에 있는 데이터를 제거한다.
  - `O(1)`의 시간복잡도를 갖는다.

```python
stack = []
stack.append(1)
stack.append(2)
stack.append(3)
stack.append(4)
print(stack[-1]) # 4 출력

stack.pop() # 맨 뒤에있는 4 제거
print(stack[-1]) # 3 출력
```



### Queue

큐는 뒤로 데이터를 넣고 앞에서 데이터를 빼는 자료구조이다. 그렇기 때문에 선입선출 `First In First Out - FIFO`의 특징을 갖고있다. 데이터를 넣은 순서대로 뺄 수 있다.

python에서 `list`를 활용하여 큐를 구현한다. 데이터를 넣을 때는 뒤에서, 뺄 때는 앞에서 빼도록 한다.

- `.append()` : 큐에 데이터를 넣는다.
- `queue[0]` : 맨 앞에있는 데이터를 가리킨다.
- `queue.pop(0)` : 맨 앞에있는 데이터를 제거한다.
  - `O(n)`의 시간복잡도를 갖는다.

```python
queue = []
queue.append(1)
queue.append(2)
queue.append(3)
queue.append(4)
print(queue[0]) # 1 출력

queue.pop(0) # 1을 제거한다.
print(queue[0]) # 2 출력
```



### Deque

덱은 데이터를 넣고 빼는 작업을 양쪽에서 할 수 있다. 즉 왼쪽에서도 데이터를 넣고 빼고, 오른쪽에서도 데이터를 넣고 뺄 수 있다. 

python에서 `list`로 큐를 구현할 때 앞에있는 데이터를 `pop(0)`으로 제거하는데 이는 `O(n)`의 시간복잡도를 갖고있기 때문에 비효율적이다. 하지만 python의 `deque`의 경우 큐에서 데이터의 제거를 `O(1)`로 할 수 있다.

먼저 `_collections`에서 `deque`를 가져온다. 

- `.popleft()` : 가장 앞에있는 원소를 반환하고 제거한다.
- `appendleft()` : 가장 앞에 원소를 추가한다.
- `.pop()`, `.append()` : `list`에 썼던 함수도 그대로 사용할 수 있다.

```python
from _collections import deque

q = deque() # 빈 덱을 생성한다.
q.append(1)
q.append(2)
q.append(3) # 데이터를 넣을 때는 append를 사용하여 뒤로 넣는다.
print(q.popleft()) # 1이 출력된다.
print(q.popleft()) # 2가 출력된다.
```



## 비선형 자료구조

### 트리

트리는 스택, 큐와 다르게 데이터를 삽입, 삭제, 수정하기 위한 자료구조가 아니라 데이터의 `계층적 관계`를 표현하기 위한 자료구조이다.