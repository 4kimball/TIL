# Sorting : Insertion Sort

> 자신의 위치를 찾아 그 자리에 삽입하면서 정렬한다.



### :orange_book: 개념

`[3, 5, 1, 9, 7]`을 오름차순 정렬한다고 하자. 삽입 정렬은 자신의 왼쪽은 정렬이 되어있고 그 사이에 자신을 어디에 넣을지 찾는 것이다.

동작을 보면 3과 5를 비교해보자. 이미 정렬이 되어있기 때문에 그 다음 5와 1을 본다. 정렬이 되어있지 않기 때문에 1과 5를 바꾼다. 그리고 이제 3과 1을 비교해보고 정렬이 되어있지 않기 때문에 자리를 바꾸면 최종적으로 1 3 5로 정렬이 되는 것을 확인할 수 있다.

이처럼 왼쪽부터 수를 증가시켜 그 수의 자리를 찾아가는 과정을 겪는다.



### :bulb: 구현

- 위의 객념을 `python`으로 구현해보자.

- 두 개의 `for`문을 사용하며 첫 번째 `for`문의 인덱스는 위치를 찾아야할 숫자를 반복시키고, 두 번째 `for`문은 첫 번째 `for`문의 인덱스의 왼쪽으로 탐색을 하여 자리를 찾는다.
- 자리를 찾아야 하는 인덱스를 `min_idx`에 저장하여 해당 인덱스의 수에 대한 자리를 찾는다.
- 두 번째 `for`문을 보면 왼쪽이 나보다 크면 자리를 바꾸는 형태이다. 그래서 작은 수가 왼쪽으로 가서 오름차순 정렬이된다.

```python
numbers = [3, 5, 1, 9, 7]

for y in range(1, len(numbers)):
    min_idx = y
    for x in range(y-1, -1, -1):
        if numbers[min_idx] < numbers[x]:
            numbers[min_idx], numbers[x] = numbers[x], numbers[min_idx]
            min_idx = x
        else:
            break

print(numbers)
```



### :hourglass_flowing_sand: 성능

- 삽입 정렬의 시간 복잡도는 **`Big-O 표기법으로 O(n^2)`**를 갖는다.
- 어느정도 정렬이 되어있다면 빠르게 되지만 최악의 경우 등차수열의 합에 해당된다.
- 두 번째 `for`문이 반복하는 횟수를 보면 `1+2+3+   +(n-2)+(n-1)`이 된다.