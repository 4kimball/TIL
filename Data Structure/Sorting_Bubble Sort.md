# Sorting : Bubble Sort

> 인접한 두 개의 데이터를 정렬해 나가는 방식으로 그 모양이 Bubble과 같다하여 붙여진 이름이다.



### :orange_book: 개념

오름차순을 기준으로 볼 때, 인접한 두 개의 데이터(현재 인덱스의 데이터와 다음 인덱스의 데이터)를 비교하여 큰 수를 뒤로보낸다. 따라서 뒤에서부터 데이터가 정렬이 된다.

더 자세하게는 알아보면,

오름차순으로 정렬을 한다고 했을 때 현재 인덱스`idx`의 수와 다음 인덱스`idx+1`의 수를 비교한다. 여기서 **현재 인덱스의 수 > 다음 인덱스의 수**라면 두 개의 위치를 변경한다. 이 과정을 **정렬해야하는 수열의 길이 -1만큼 반복**하게 된다.

수열의 인덱스가 0`~`4 라면, (0, 1) (1, 2) (2, 3) (3, 4)의 순서대로 비교하게 된다.



### :bulb: 구현

- `python`을 통해 코드로 구현해보자.
- 다음과 같은 수열을 포함한 `list`인 **numbers**가 있다고 하자.

```python
numbers = [3, 7, 5, 1, 9]
```

- 위의 수열을 **버블정렬**을 통해 정렬하려면 다음과 같이 구현해야 한다.
- `(1)` : 버블정렬은 `수열의 길이-1`만큼 반복해야한다. 이를 위해 `len()-1`을 사용했다.
- `(2)` : 버블정렬은 뒤에서부터 정렬이 된다. 따라서 수열의 길이가 5일 때, 다음 인덱스의 끝이 3, 2, 1, 0이 되도록한다.
- `(3)` : 현재 인덱스가 다음 인덱스보다 크다면 **스왑**을 통해 데이터를 변경해준다.

```python
for n in range(len(numbers)-1): # (1)
    for idx in range(0, len(numbers)-n-1): # (2)
        
        if numbers[idx] > numbers[idx+1]: # (3)
            temp = numbers[idx]
            numbers[idx] = numbers[idx+1]
            numbers[idx+1] = temp
```

- 최종적으로 오름차순으로 정렬된 결과가 출력된다.

```python
print(numbers)
# [1, 3, 5, 7, 9]
```



### :hourglass_flowing_sand: 성능

정렬 알고리즘의 성능은 `비교 횟수`와 `이동 횟수`를 통해 판단할 수 있다.

버블 정렬의 경우 비교를 하면서 이동이 진행되기 때문에 `if`문이 얼마나 실행되는지로 성능을 평가할 수 있다.

구현에서 코드를 보면 최악의 경우 `if`문은 **4 + 3 + 2 + 1**번 진행되며 이는 등차수열의 합에 해당된다. `n^2 - n / 2`은 **Big-O 표기법**으로 `O(n^2)`가 된다.

