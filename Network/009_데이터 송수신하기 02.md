# 데이터 송수신하기 02

> 이전에 데이터 송수신 동작을 알아봤으며 그 다음 송수신을 확인하는 ACK와 송수신 동작의 마무리를 공부해본다.



### :one: ACK 번호를 언제까지 기다릴까?

- 송신측에서 데이터를 보내고 수신측에서는 데이터를 잘 받았다는 의미로 ACK 번호를 반송한다. 이때 송신측은 일정시간 ACK가 오지않는다면 데이터를 다시보내는데 송신측에서는 언제까지 ACK를 기다릴까?
- **타임아웃 값**은 ACK 번호가 돌아오는 것을 기다리는 시간이다. 타임아웃 값을 길게 잡으면 패킷을 다시 보내는 동작이 지연되고 짧게 잡는다면 헛된 패킷을 계속 보낼 수 있어 네트워크가 혼잡해진다. 따라서 적당한 시간을 설정해야한다.
- TCP는 타임아웃 값을 동적으로 변경한다. ACK 번호가 돌아오는 시간을 기준으로 대기 시간을 판단하며 이를 위해 ACK 번호가 돌아오는 시간을 계측해 둔다.



### :two: ACK 번호만 기다리고 있는 것은 비효율적

- 송신측에서 한 개의 패킷을 보내고 ACK를 기다리는 것은 ACK가 올 때까지 아무것도 하지 않게되기 때문에 비효율적이다.
- 이를 위해 **윈도우 제어 방식**으로 송신과 ACK 번호 통지의 동작을 실행하는데 윈도우 제어는 한 개의 패킷을 보내고 ACK 번호를 기다리지 않고 바로 다음  패킷을 전송한다. ACK가 돌아올 때까지 여러 개의 패킷을 보내며 시간 낭비를 줄일 수 있다.
- 하지만 수신측에서는 수신한 패킷을 수신용 버퍼 메모리에 저장을 하는데 이는 크기가 정해져있다. **무한대로 패킷을 받을 수 없다.** 따라서 수신 가능한 데이터 양을 송신측에 전달하여 송신측에서 수신측의 상황을 보고 패킷을 전달할 수 있도록 한다.
- 이처럼 수신 가능한 데이터 양의 최댓값을 **윈도우 사이즈**라고 한다.
- ACK번호와 윈도우는 하나의 패킷으로 통합하여 보내 여러 개의 패킷을 보내지 않게하여 효율을 높인다.



### :three: 브라우저가 read를 호출한다.

- 클라이언트가 요청한 데이터가 서버에서 송신되었다면 데이터를 받기위해 read를 호출한다. 
- 프로토콜 스택은 수신 버퍼에 데이터를 저장해두었다가 수신 데이터를 추출하여 애플리케이션에 전달한다.
- 프로토콜 스택은 수신한 데이터 조각과 TCP 헤더를 조사하여 누락된 데이터가 없는지 검사하고 ACK를 반송한다. 이후 데이터 조각을 수신 버퍼에 저장하고 조각들을 연결하여 원래의 데이터 형태로 애플리케이션에 전달하게 된다.

.