# Algorithm





## 문자열



### KMP

LPS를 활용하여 패턴이 갖는 문자를 찾는다.

`LPS` 테이블을 활용한다.

지금까지는 leng이 가리키는 문자와 i가 가리키는 문자가 같다면 i에 leng+1을 넣고 i와 leng 모두 1증가

만약 다르다면

leng 0이 아니라는 것은 뒤에 같은 글자가 존재할 수도 => leng을 0이 있는 곳으로 보내기

leng이 0이라면 해당 자리를 0으로 넣고 i증가



```python
def make_lps(word):
    leng = 0
    lps = [0] * len(word)

    i = 1

    while i < len(word):
        if word[leng]==word[i]:
            leng += 1
            lps[i] = leng
            i += 1
        else:
            if leng != 0:
                leng = lps[leng-1]
            else:
                lps[i] = 0
                i += 1
```





## Greedy

> 매 순간 최적의 해를 선택하는 탐욕 알고리즘



:bulb: 어떤 문제의 **최적해**를 구한다고 했을 때, 모든 경우의 수를 탐색하고 그 중 최적이 되는 것을 선택할 수 있을 것이다. 여기서 **모든 경우의 수**를 탐색하기 위해 문제를 여러 개의 조각으로 나누게된다. 여러 개의 조각마다 최적의 선택을 하면 최종적으로 **최적해**를 구할 수 있을까?



### 개념

`Greedy`는 각 단계의 선택지에서 매번 가장 최적의 수만 선택하는 것이다. 하지만 항상 최적해를 구할 수 있는 것은 아니다. 이 알고리즘은 모든 경우의 수를 탐색하는데 시간이 오래걸리기 때문에 빠르게 최적해를 구하도록 설계된 알고리즘이다. 하지만 빠르다고 무조건 좋은 알고리즘은 아니다. :satisfied:

`완전탐색` , `동적계획법`으로 문제를 해결할 때 하나의 작은 문제들로 나누어 풀때가 있다. 이때 나눈 작은 문제들의 최적해를 모아섯 최종적인 최적해를 구하는 알고리즘이다.

하지만 현재의 최적의 선택이 최종적인 최적해를 보장하지 않는다. 따라서 작은 문제들의 최적해가 최종적으로 최적해인지 **증명**할 필요가 있다.



